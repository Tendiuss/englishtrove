// Version: 1.1.0 - Python HTTP server only implementation
console.log('Scripts.js loaded - Version 1.1.0');

// Check if loadFiles function already exists
if (window.loadFilesOriginal) {
    console.log('WARNING: loadFiles function already exists. This might cause conflicts.');
} else {
    window.loadFilesOriginal = true;
}

// Intercept fetch calls to debug
const originalFetch = window.fetch;
window.fetch = function(url, options) {
    console.log(`Intercepted fetch call to: ${url}`, options);
    return originalFetch.apply(this, arguments);
};

// Initialize modal elements if they exist
const modal = document.getElementById('pdf-modal');
const closeButton = document.querySelector('.close-button');
const pdfPreviewContainer = document.getElementById('pdf-preview-container');

// Only set up modal events if elements exist
if (modal && closeButton && pdfPreviewContainer) {
    // Close modal when clicking the close button or outside the modal
    closeButton.onclick = () => {
        modal.style.display = 'none';
        // Clear the container when closing
        pdfPreviewContainer.innerHTML = '<canvas id="pdf-preview"></canvas>';
    };

    window.onclick = (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
            // Clear the container when closing
            pdfPreviewContainer.innerHTML = '<canvas id="pdf-preview"></canvas>';
        }
    };
}

// Function to extract files from directory listing HTML generated by Python HTTP server
function extractFilesFromHTML(html, category) {
    console.log('Extracting files from HTML directory listing');
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Python's simple HTTP server has links in a <ul> or directly in the <pre> tag
    const links = doc.querySelectorAll('a');
    console.log(`Found ${links.length} links in directory listing`);
    
    const files = [];
    links.forEach(link => {
        const href = link.getAttribute('href');
        // Skip parent directory links and non-file links
        if (href === '../' || href === './' || href.endsWith('/')) {
            console.log(`Skipping directory link: ${href}`);
            return;
        }
        
        // Only include PDF files (can be expanded to include other file types if needed)
        if (href.toLowerCase().endsWith('.pdf')) {
            // Create a file object similar to what the API would return
            files.push({
                name: decodeURIComponent(href),
                path: `/materials/${category}/${href}`,
                description: ''
            });
            console.log(`Added file: ${href}`);
        } else {
            console.log(`Skipping non-PDF file: ${href}`);
        }
    });
    
    console.log(`Extracted ${files.length} PDF files from HTML`);
    return files;
}

// Function to show PDF preview
async function showPDFPreview(url) {
    if (!modal) return;
    
    const pdfPreviewCanvas = document.getElementById('pdf-preview');
    modal.style.display = 'block';

    try {
        // Show loading state
        pdfPreviewContainer.innerHTML = '<div class="loading">Loading PDF...</div>';

        // Load the PDF
        const loadingTask = pdfjsLib.getDocument(url);
        const pdf = await loadingTask.promise;
        
        // Get the first page
        const page = await pdf.getPage(1);
        
        // Calculate scale to fit the container width
        const desiredWidth = pdfPreviewContainer.clientWidth - 40; // Account for padding
        const viewport = page.getViewport({ scale: 1.0 });
        const scale = desiredWidth / viewport.width;
        const scaledViewport = page.getViewport({ scale });

        // Prepare canvas
        pdfPreviewContainer.innerHTML = '<canvas id="pdf-preview"></canvas>';
        const canvas = document.getElementById('pdf-preview');
        const context = canvas.getContext('2d');

        // Set canvas dimensions
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;

        // Render PDF page
        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };

        await page.render(renderContext);
    } catch (error) {
        console.error('Error loading PDF:', error);
        pdfPreviewContainer.innerHTML = '<div class="error">Error loading PDF. Please try again.</div>';
    }
}

// Global variable to store file data
let fileData = {};

// Function to load files for a specific category
function loadFiles(category) {
    console.log(`Loading files for category: ${category}`);
    
    const container = document.getElementById(`${category}-files`);
    if (!container) {
        console.error(`Container for ${category} not found`);
        return;
    }
    
    // Show loading indicator
    container.innerHTML = '<p class="loading">Loading files...</p>';
    
    // Log which fetch we're using
    console.log(`Using fetch: ${fetch.toString().slice(0, 50)}...`);
    
    // Get the URL we're fetching
    const url = `/materials/${category}/`;
    
    console.log(`Fetching from URL: ${url}`);
    
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.status}`);
            }
            // Try to parse as JSON first
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return response.json();
            } else {
                // If not JSON, it's probably HTML directory listing
                return response.text().then(html => {
                    return extractFilesFromHTML(html, category);
                });
            }
        })
        .then(files => {
            console.log(`Received ${files.length} files for ${category}`);
            
            // Deduplicate files based on name to prevent UI confusion
            const uniqueFiles = [];
            const fileNameSet = new Set();
            
            files.forEach(file => {
                if (!fileNameSet.has(file.name)) {
                    fileNameSet.add(file.name);
                    uniqueFiles.push(file);
                } else {
                    console.log(`Skipping duplicate file: ${file.name}`);
                }
            });
            
            // Store the files in our global object for later use
            fileData[category] = uniqueFiles;
            
            // Clear loading message
            container.innerHTML = '';
            
            // Update the section header with file count
            const sectionHeader = document.querySelector(`#${category}-section .section-header h2`);
            if (sectionHeader) {
                // Remove any existing file count
                const existingCount = sectionHeader.querySelector('.file-count');
                if (existingCount) {
                    existingCount.remove();
                }
                
                const fileCount = document.createElement('span');
                fileCount.classList.add('file-count');
                fileCount.textContent = `(${uniqueFiles.length})`;
                sectionHeader.appendChild(fileCount);
            }
            
            if (uniqueFiles.length === 0) {
                container.innerHTML = '<p class="no-files">No files available in this category</p>';
                return;
            }
            
            // Create file items
            uniqueFiles.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.classList.add('file-item');
                fileItem.dataset.fileName = file.name.toLowerCase();
                fileItem.dataset.fileCategory = category;
                
                const fileContent = document.createElement('div');
                fileContent.classList.add('file-content');
                
                const fileName = document.createElement('div');
                fileName.classList.add('file-name');
                
                // Add title attribute to show full name on hover
                fileName.setAttribute('title', file.name);
                
                // Completely revised truncation for better distinction between similar files
                if (file.name.length > 35) {
                    // Extract key parts of the filename for better identification
                    const parts = file.name.split(' - ');
                    let displayName;
                    
                    if (parts.length >= 3) {
                        // For files with structure "A1 - Simple Present Tense - Multiple Choice"
                        const level = parts[0]; // e.g., A1, B2
                        const topic = parts[1]; // e.g., Simple Present Tense
                        const type = parts[parts.length-1]; // e.g., Multiple Choice
                        
                        // Include a portion of the middle to distinguish between similar items
                        const topicWords = topic.split(' ');
                        const shortenedTopic = topicWords.length > 2 
                            ? `${topicWords[0]} ${topicWords[1]}...` 
                            : `${topic.substring(0, 12)}...`;
                        
                        // Format: "A1 - Simple Present... - Multiple Choice"
                        displayName = `${level} - ${shortenedTopic} - ${type}`;
                        
                        // Add a dataset attribute to help with styling based on the level
                        fileItem.dataset.level = level;
                    } else if (parts.length === 2) {
                        // For files with structure "A1 - Present Continuous Tense"
                        const level = parts[0];
                        const topic = parts[1];
                        
                        // Create a distinctive shortened version
                        let shortenedTopic;
                        if (topic.length > 25) {
                            shortenedTopic = topic.substring(0, 22) + '...';
                        } else {
                            shortenedTopic = topic;
                        }
                        
                        displayName = `${level} - ${shortenedTopic}`;
                        fileItem.dataset.level = level;
                    } else {
                        // Fallback to simple truncation with a more distinctive pattern
                        displayName = file.name.substring(0, 30) + '...';
                    }
                    
                    fileName.setAttribute('data-full-name', file.name);
                    fileName.textContent = displayName;
                } else {
                    fileName.textContent = file.name;
                    
                    // Still extract the level if possible for styling
                    const parts = file.name.split(' - ');
                    if (parts.length > 0 && (parts[0].startsWith('A') || parts[0].startsWith('B') || parts[0].startsWith('C'))) {
                        fileItem.dataset.level = parts[0];
                    }
                }
                
                fileContent.appendChild(fileName);
                
                if (file.description) {
                    const fileDescription = document.createElement('div');
                    fileDescription.classList.add('file-description');
                    fileDescription.textContent = file.description;
                    fileContent.appendChild(fileDescription);
                }
                
                fileItem.appendChild(fileContent);
                
                // Improved button container with proper alignment
                const buttonContainer = document.createElement('div');
                buttonContainer.classList.add('button-container');
                
                // Create Details button with icon
                const detailsButton = document.createElement('button');
                detailsButton.classList.add('details-button');
                detailsButton.innerHTML = '<i class="fas fa-info-circle"></i> Details';
                detailsButton.addEventListener('click', () => showFileDetails(file, category));
                buttonContainer.appendChild(detailsButton);
                
                // Create Download button with icon
                const downloadButton = document.createElement('button');
                downloadButton.classList.add('download-button');
                downloadButton.innerHTML = '<i class="fas fa-download"></i> Download';
                downloadButton.addEventListener('click', () => downloadFile(file.path));
                buttonContainer.appendChild(downloadButton);
                
                fileItem.appendChild(buttonContainer);
                container.appendChild(fileItem);
            });
        })
        .catch(error => {
            console.error(`Error loading files for ${category}:`, error);
            container.innerHTML = `<p class="error">Error loading files: ${error.message}</p>`;
        });
}

// Function to refresh all materials
async function refreshAllMaterials() {
    console.log('Refreshing all materials');
    
    // Clear existing files
    document.querySelectorAll('.files-container').forEach(container => {
        container.innerHTML = '<p class="loading">Loading files...</p>';
    });
    
    // Reload all categories
    await loadFiles('grammar');
    await loadFiles('vocabulary');
    await loadFiles('speaking');
    await loadFiles('writing');
    await loadFiles('lesson-plans');
    await loadFiles('worksheets');
}

// Function to initialize detail page
async function initMaterialDetailPage() {
    console.log('Initializing material detail page');
    const params = new URLSearchParams(window.location.search);
    const filePath = params.get('file');

    if (!filePath) {
        console.error('File path is missing');
        document.querySelector('.material-container').innerHTML = '<div class="error">Error: No file specified</div>';
        return;
    }

    // Show loading state
    const titleElement = document.getElementById('material-title');
    if (titleElement) {
        titleElement.textContent = 'Loading...';
    }

    try {
        // Extract file name and category from the path
        const fileName = decodeURIComponent(filePath).split('/').pop();
        // The category is the second part of the path after /materials/
        const pathParts = filePath.split('/');
        const category = pathParts.length > 2 ? pathParts[2] : 'unknown';
        
        console.log(`Loading detail for file: ${fileName} from category: ${category}`);
        
        if (titleElement) {
            titleElement.textContent = fileName;
        }
        
        const categoryElement = document.getElementById('material-category');
        if (categoryElement) {
            categoryElement.textContent = category;
        }
        
        // Set up download button
        const downloadButton = document.getElementById('download-button');
        if (downloadButton) {
            downloadButton.href = filePath;
            downloadButton.download = fileName;
        }

        // Set up print button
        const printButton = document.getElementById('print-button');
        if (printButton) {
            printButton.addEventListener('click', () => {
                window.print();
            });
        }

        // Load and display the PDF preview
        const canvas = document.getElementById('pdf-canvas');
        if (canvas) {
            try {
                console.log(`Attempting to load PDF from: ${filePath}`);
                const context = canvas.getContext('2d');
                const loadingTask = pdfjsLib.getDocument(filePath);
                const pdf = await loadingTask.promise;
                console.log(`PDF loaded with ${pdf.numPages} pages`);
                
                const page = await pdf.getPage(1);
                
                const desiredWidth = canvas.parentElement.clientWidth - 40;
                const viewport = page.getViewport({ scale: 1.0 });
                const scale = desiredWidth / viewport.width;
                const scaledViewport = page.getViewport({ scale });

                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;

                await page.render({
                    canvasContext: context,
                    viewport: scaledViewport
                });
                console.log('PDF rendered successfully');
            } catch (error) {
                console.error('Error loading PDF:', error);
                canvas.parentElement.innerHTML = `<div class="error">Error loading PDF: ${error.message}</div>`;
            }
        }
    } catch (error) {
        console.error('Error loading material:', error);
        if (titleElement) {
            titleElement.textContent = 'Error loading material';
        }
        document.querySelector('.material-info').innerHTML += `<div class="error">Error: ${error.message}</div>`;
    }
}

// Function to filter materials
function filterMaterials(searchTerm) {
    const fileItems = document.querySelectorAll('.file-item');
    searchTerm = searchTerm.toLowerCase();

    fileItems.forEach(item => {
        const fileName = item.querySelector('.file-name').textContent.toLowerCase();
        item.style.display = fileName.includes(searchTerm) ? 'flex' : 'none';
    });
}

// Initialize search functionality
function initializeSearch() {
    const searchInput = document.getElementById('search-input');
    if (!searchInput) return;
    
    console.log('Initializing search functionality');
    
    // Create suggestions container
    const suggestionsContainer = document.createElement('div');
    suggestionsContainer.className = 'search-suggestions';
    suggestionsContainer.style.display = 'none';
    searchInput.parentNode.appendChild(suggestionsContainer);
    
    let activeIndex = -1;
    let suggestions = [];
    
    // Handle input in the search box
    searchInput.addEventListener('input', () => {
        const searchTerm = searchInput.value.trim();
        if (searchTerm.length < 2) {
            suggestionsContainer.style.display = 'none';
            activeIndex = -1;
            return;
        }
        
        // Check if we're on the home page
        const isHomePage = window.location.pathname === '/' || 
                          window.location.pathname.endsWith('/index.html') ||
                          document.querySelector('.hero-section') !== null;
                          
        if (isHomePage) {
            // If on home page, just show option to redirect to materials page with search
            suggestionsContainer.innerHTML = '';
            
            const redirectItem = document.createElement('div');
            redirectItem.className = 'suggestion-item';
            redirectItem.innerHTML = `
                <div class="suggestion-content">
                    <div class="suggestion-text">
                        Search for "<span class="suggestion-highlight">${searchTerm}</span>" in materials
                    </div>
                    <div class="suggestion-category">Go to Materials</div>
                </div>
            `;
            
            redirectItem.addEventListener('click', () => {
                window.location.href = './materials.html?search=' + encodeURIComponent(searchTerm);
            });
            
            suggestionsContainer.appendChild(redirectItem);
            suggestionsContainer.style.display = 'block';
            return;
        }
        
        // On materials page, perform normal search
        showSearchSuggestions(searchTerm);
    });
    
    // Handle keyboard navigation in suggestions
    searchInput.addEventListener('keydown', (e) => {
        if (suggestionsContainer.style.display === 'none') return;
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIndex = Math.min(activeIndex + 1, suggestions.length - 1);
            updateActiveSuggestion();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIndex = Math.max(activeIndex - 1, 0);
            updateActiveSuggestion();
        } else if (e.key === 'Enter' && activeIndex >= 0) {
            e.preventDefault();
            suggestions[activeIndex].click();
        } else if (e.key === 'Escape') {
            suggestionsContainer.style.display = 'none';
            activeIndex = -1;
        }
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
            suggestionsContainer.style.display = 'none';
            activeIndex = -1;
        }
    });
    
    // Function to update active suggestion styling
    function updateActiveSuggestion() {
        const items = suggestionsContainer.querySelectorAll('.suggestion-item');
        items.forEach((item, index) => {
            if (index === activeIndex) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
        
        // Ensure active item is visible in scroll
        if (activeIndex >= 0) {
            const activeItem = items[activeIndex];
            activeItem.scrollIntoView({ block: 'nearest' });
        }
    }
    
    // Function to show search suggestions based on search term
    function showSearchSuggestions(searchTerm) {
        console.log('Showing suggestions for:', searchTerm);
        suggestionsContainer.innerHTML = '';
        activeIndex = -1;
        suggestions = [];
        
        // Check if we're on the home page
        const isHomePage = window.location.pathname === '/' || 
                          window.location.pathname.endsWith('/index.html') ||
                          document.querySelector('.hero-section') !== null;
                          
        if (isHomePage) {
            // Create redirect suggestion
            const redirectItem = document.createElement('div');
            redirectItem.className = 'suggestion-item';
            redirectItem.innerHTML = `
                <div class="suggestion-content">
                    <div class="suggestion-text">
                        Search for "<span class="suggestion-highlight">${searchTerm}</span>" in materials
                    </div>
                    <div class="suggestion-category">Go to Materials</div>
                </div>
            `;
            
            redirectItem.addEventListener('click', () => {
                window.location.href = './materials.html?search=' + encodeURIComponent(searchTerm);
            });
            
            suggestionsContainer.appendChild(redirectItem);
            suggestions.push(redirectItem);
            suggestionsContainer.style.display = 'block';
            return;
        }
        
        // Find matching files in the materials page
        const searchRegex = new RegExp(searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
        const fileItems = document.querySelectorAll('.file-item');
        const matchingFiles = [];
        
        // Track unique filenames to avoid duplicates
        const uniqueFileNames = new Set();
        
        fileItems.forEach(fileItem => {
            const fileName = fileItem.querySelector('.file-name').textContent;
            
            // Skip if we already have a very similar filename
            let isDuplicate = false;
            for (const existingName of uniqueFileNames) {
                // If filenames are 80% similar, consider it a duplicate
                if (similarityScore(fileName, existingName) > 0.8) {
                    isDuplicate = true;
                    break;
                }
            }
            
            if (isDuplicate) return;
            
            const fileCategory = fileItem.closest('.material-section').querySelector('.section-header h2').textContent;
            
            if (searchRegex.test(fileName)) {
                uniqueFileNames.add(fileName);
                
                // Calculate a more precise relevance score
                // 1. Exact match gets highest priority
                // 2. Starting with the term gets next priority
                // 3. Position of match gets lowest priority
                let relevance = 1000;
                
                const lowerFileName = fileName.toLowerCase();
                const lowerSearchTerm = searchTerm.toLowerCase();
                
                if (lowerFileName === lowerSearchTerm) {
                    relevance = 0; // Exact match
                } else if (lowerFileName.startsWith(lowerSearchTerm)) {
                    relevance = 1; // Starts with the term
                } else {
                    relevance = lowerFileName.indexOf(lowerSearchTerm) + 100; // Position of match
                }
                
                matchingFiles.push({
                    element: fileItem,
                    fileName: fileName,
                    fileCategory: fileCategory,
                    relevance: relevance
                });
            }
        });
        
        // Sort by relevance - lower relevance score = higher priority
        matchingFiles.sort((a, b) => a.relevance - b.relevance);
        
        // Limit to top 4 results to avoid overwhelming the UI
        const topResults = matchingFiles.slice(0, 4);
        
        if (topResults.length === 0) {
            const noResultItem = document.createElement('div');
            noResultItem.className = 'suggestion-no-results';
            noResultItem.textContent = 'No files match your search';
            suggestionsContainer.appendChild(noResultItem);
        } else {
            topResults.forEach(result => {
                const suggestionItem = document.createElement('div');
                suggestionItem.className = 'suggestion-item';
                
                // Truncate filename if too long
                let displayFileName = result.fileName;
                if (displayFileName.length > 40) {
                    // Try to truncate at a sensible place
                    const firstPart = displayFileName.substring(0, 20);
                    const lastPart = displayFileName.substring(displayFileName.length - 15);
                    displayFileName = `${firstPart}...${lastPart}`;
                }
                
                // Highlight the matching text in the file name
                const highlightedName = displayFileName.replace(
                    searchRegex,
                    match => `<span class="suggestion-highlight">${match}</span>`
                );
                
                suggestionItem.innerHTML = `
                    <div class="suggestion-content">
                        <div class="suggestion-text">${highlightedName}</div>
                        <div class="suggestion-category">${result.fileCategory}</div>
                    </div>
                `;
                
                suggestionItem.addEventListener('click', () => {
                    // Clear any previous selected items
                    document.querySelectorAll('.file-item.search-selected').forEach(item => {
                        item.classList.remove('search-selected');
                    });
                    
                    // Mark this file as selected
                    result.element.classList.add('search-selected');
                    
                    // Make sure the section containing this file is expanded
                    const section = result.element.closest('.material-section');
                    if (section.classList.contains('collapsed')) {
                        const header = section.querySelector('.section-header');
                        header.click(); // Expand the section
                    }
                    
                    // Scroll the file into view
                    setTimeout(() => {
                        result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                    
                    // Hide suggestions
                    suggestionsContainer.style.display = 'none';
                });
                
                suggestionsContainer.appendChild(suggestionItem);
                suggestions.push(suggestionItem);
            });
        }
        
        suggestionsContainer.style.display = 'block';
    }
    
    // Function to calculate string similarity (0-1 where 1 is identical)
    function similarityScore(str1, str2) {
        const s1 = str1.toLowerCase();
        const s2 = str2.toLowerCase();
        
        // If strings are identical
        if (s1 === s2) return 1.0;
        
        // If one string is contained in the other
        if (s1.includes(s2) || s2.includes(s1)) return 0.9;
        
        // Calculate Levenshtein distance
        const len1 = s1.length;
        const len2 = s2.length;
        const maxLen = Math.max(len1, len2);
        
        // Use a simplified approach for long strings
        if (maxLen > 30) {
            // Compare first and last 10 chars
            const s1Start = s1.substring(0, 10);
            const s2Start = s2.substring(0, 10);
            const s1End = s1.substring(Math.max(0, len1 - 10));
            const s2End = s2.substring(Math.max(0, len2 - 10));
            
            if (s1Start === s2Start && s1End === s2End) return 0.85;
            if (s1Start === s2Start) return 0.7;
            if (s1End === s2End) return 0.6;
        }
        
        // Check if they share key terms
        const commonTerms = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'Present', 'Past', 'Future', 'Tense', 'Multiple Choice'];
        let commonCount = 0;
        
        for (const term of commonTerms) {
            if (s1.includes(term.toLowerCase()) && s2.includes(term.toLowerCase())) {
                commonCount++;
            }
        }
        
        if (commonCount >= 3) return 0.8;
        if (commonCount >= 2) return 0.7;
        
        // Otherwise return a lower similarity
        return 0.5;
    }
    
    // Check for search parameter in URL when page loads
    checkForSearchParameter();
}

// Function to check if there's a search parameter in the URL
function checkForSearchParameter() {
    const urlParams = new URLSearchParams(window.location.search);
    const searchTerm = urlParams.get('search');
    
    if (searchTerm) {
        console.log('Found search parameter in URL:', searchTerm);
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.value = searchTerm;
            
            // Wait for materials to load before showing results
            setTimeout(() => {
                const event = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(event);
            }, 500);
        }
    }
}

// Setup section toggles to expand/collapse material sections
function setupSectionToggles() {
    const headers = document.querySelectorAll('.section-header');
    if (headers.length === 0) return;
    
    console.log('Setting up section toggles for', headers.length, 'sections');
    
    headers.forEach(header => {
        header.addEventListener('click', (e) => {
            // Don't toggle if a button inside the header was clicked
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                return;
            }
            
            const section = header.closest('.material-section');
            const filesContainer = section.querySelector('.files-container');
            const toggleIcon = header.querySelector('.toggle-icon');
            
            console.log('Section header clicked:', header.querySelector('h2').textContent);
            
            // Check if we're in search mode and this section has results
            const isSearchActive = document.getElementById('search-input')?.value.trim().length > 0;
            const hasSearchResults = section.querySelector('.file-item.search-selected') !== null;
            
            // If searching and this section has results, don't collapse it
            if (isSearchActive && hasSearchResults) {
                console.log('Search active and section has results - preventing collapse');
                return;
            }
            
            const isCollapsed = section.classList.contains('collapsed');
            console.log('Current collapsed state:', isCollapsed);
            
            if (isCollapsed) {
                // Expand the section
                section.classList.remove('collapsed');
                header.setAttribute('aria-expanded', 'true');
                
                // Show the files container with animation
                if (filesContainer) {
                    filesContainer.style.maxHeight = '500px';
                    filesContainer.style.padding = '1rem';
                    filesContainer.style.overflow = 'auto';
                    filesContainer.style.visibility = 'visible';
                    filesContainer.style.display = 'flex';
                }
                
                // Rotate the toggle icon
                if (toggleIcon) {
                    toggleIcon.style.transform = 'rotate(0deg)';
                }
            } else {
                // Collapse the section
                section.classList.add('collapsed');
                header.setAttribute('aria-expanded', 'false');
                
                // Hide the files container with animation
                if (filesContainer) {
                    filesContainer.style.maxHeight = '0';
                    filesContainer.style.padding = '0 1rem';
                    filesContainer.style.overflow = 'hidden';
                    filesContainer.style.visibility = 'hidden';
                    filesContainer.style.display = 'none';
                }
                
                // Rotate the toggle icon
                if (toggleIcon) {
                    toggleIcon.style.transform = 'rotate(-90deg)';
                }
            }
        });
    });
}

function showFileDetails(file, category) {
    console.log(`Showing details for file: ${file.name} in category: ${category}`);
    // Redirect to the material detail page with the file path
    window.location.href = `/material_detail.html?file=${encodeURIComponent(file.path)}`;
}

function downloadFile(filePath) {
    console.log(`Downloading file from path: ${filePath}`);
    // With Python HTTP server, we can directly download the file
    // No need for a special download endpoint
    window.location.href = filePath;
}

function setupRefreshButton() {
    const refreshButton = document.getElementById('refresh-button');
    if (refreshButton) {
        refreshButton.addEventListener('click', refreshAllMaterials);
    } else {
        console.error('Refresh button not found');
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM content loaded');
    try {
        // Initialize search
        initializeSearch();
        
        // Setup section toggles
        setupSectionToggles();
        
        // Setup refresh button
        setupRefreshButton();
        
        // Check which page we're on and initialize appropriately
        if (window.location.pathname.includes('material_detail.html')) {
            console.log('On material detail page');
            initMaterialDetailPage();
        } else if (window.location.pathname.includes('materials.html') || window.location.pathname.endsWith('/materials')) {
            console.log('On materials listing page');
            // Load all categories
            loadFiles('grammar');
            loadFiles('vocabulary');
            loadFiles('speaking');
            loadFiles('writing');
            loadFiles('lesson-plans');
            loadFiles('worksheets');
        }
    } catch (error) {
        console.error('Error during initialization:', error);
    }
});

// Re-initialize search when navigating back/forward
window.addEventListener('popstate', async () => {
    initializeSearch();
    
    if (window.location.pathname.includes('materials.html')) {
        await refreshAllMaterials();
    }
    
    if (window.location.pathname.includes('material_detail.html')) {
        await initMaterialDetailPage();
    }
});
